<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEUROSNATCH</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800;900&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg: #0a0a0f;
            --surface: rgba(255, 255, 255, 0.03);
            --border: rgba(255, 255, 255, 0.06);
            --text: #e8e8f0;
            --text-dim: rgba(255, 255, 255, 0.4);
            --cyan: #00f0ff;
            --cyan-glow: rgba(0, 240, 255, 0.3);
            --purple: #a855f7;
            --purple-glow: rgba(168, 85, 247, 0.3);
            --green: #22c55e;
            --calm-color: #6ee7b7;
            --excited-color: #f472b6;
        }

        html,
        body {
            height: 100%;
            width: 100%;
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            cursor: default;
        }

        /* === CANVAS BACKGROUND === */
        #waveCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.4;
        }

        /* === MAIN CONTAINER === */
        .container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* === SCREENS (state-based) === */
        .screen {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
        }

        /* === STATUS BAR (top) === */
        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(10, 10, 15, 0.9) 0%, transparent 100%);
        }

        .status-bar .logo {
            font-size: 0.85rem;
            font-weight: 800;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--cyan), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .logo-img {
            vertical-align: middle;
            object-fit: contain;
        }

        .logo-img-sm {
            height: 1.4rem;
        }

        .logo-img-lg {
            height: clamp(3rem, 7vw, 6rem);
            margin-right: 0.5rem;
        }

        .status-bar .right-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .status-bar .phase {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-dim);
            letter-spacing: 0.1em;
        }

        .status-bar .phase .dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 8px;
            background: var(--green);
            animation: dotPulse 2s ease-in-out infinite;
        }

        @keyframes dotPulse {

            0%,
            100% {
                opacity: 0.4;
            }

            50% {
                opacity: 1;
            }
        }

        /* === IDLE SCREEN === */
        .title {
            font-size: clamp(3rem, 8vw, 7rem);
            font-weight: 900;
            letter-spacing: -0.03em;
            background: linear-gradient(135deg, var(--cyan), var(--purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            animation: titlePulse 4s ease-in-out infinite;
        }

        @keyframes titlePulse {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.3);
            }
        }

        .subtitle {
            font-size: 1.1rem;
            font-weight: 300;
            color: var(--text-dim);
            margin-top: 0.5rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
        }

        .start-btn {
            margin-top: 3rem;
            padding: 1.2rem 3.5rem;
            background: transparent;
            border: 1px solid var(--cyan);
            color: var(--cyan);
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 60px;
            transition: all 0.3s ease;
        }

        .start-btn:hover {
            background: rgba(0, 240, 255, 0.1);
            box-shadow: 0 0 40px var(--cyan-glow), inset 0 0 40px rgba(0, 240, 255, 0.05);
            transform: scale(1.05);
        }

        .start-btn:active {
            transform: scale(0.98);
        }

        /* === EEG CONFIG DROPDOWNS === */
        .eeg-config {
            display: flex;
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .config-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.4rem;
        }

        .config-row label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--text-dim);
        }

        .config-row select {
            appearance: none;
            -webkit-appearance: none;
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            padding: 0.5rem 2rem 0.5rem 0.8rem;
            border-radius: 8px;
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23888' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.6rem center;
        }

        .config-row select:hover,
        .config-row select:focus {
            border-color: var(--cyan);
        }

        .config-row select option {
            background: #1a1a2e;
            color: var(--text);
        }

        /* === VIDEO PLAYER SCREEN === */
        .video-screen {
            position: absolute;
            inset: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .video-screen video {
            width: 85%;
            max-height: 75%;
            object-fit: contain;
            flex-shrink: 1;
        }

        /* === EEG LIVE GRAPH === */
        .eeg-graph-wrap {
            width: 85%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 0.3rem;
        }

        .eeg-graph {
            width: 100%;
            height: 80px;
            border: 1px solid rgba(0, 200, 255, 0.2);
            border-radius: 6px;
            background: rgba(0, 10, 20, 0.6);
        }

        .eeg-graph-label {
            margin-top: 0.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: rgba(0, 200, 255, 0.7);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .video-label {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.5rem 1.5rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--border);
            border-radius: 30px;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .video-label.calm {
            color: var(--calm-color);
            border-color: var(--calm-color);
        }

        .video-label.excited {
            color: var(--excited-color);
            border-color: var(--excited-color);
        }

        .video-timer {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: rgba(255, 255, 255, 0.6);
            z-index: 10;
        }

        /* === RESULT SCREEN === */
        .result-container {
            text-align: center;
        }

        .result-pre {
            font-size: 1rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 1rem;
            animation: fadeInUp 1s ease;
        }

        .result-choice {
            font-size: clamp(3rem, 7vw, 6rem);
            font-weight: 900;
            letter-spacing: -0.02em;
            animation: resultReveal 1.5s ease;
        }

        .result-choice.calm {
            background: linear-gradient(135deg, #6ee7b7, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .result-choice.excited {
            background: linear-gradient(135deg, #f472b6, #f59e0b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .result-emoji {
            font-size: 4rem;
            animation: resultReveal 1.5s ease 0.3s both;
        }

        .result-desc {
            font-size: 1.1rem;
            color: var(--text-dim);
            font-weight: 300;
            margin-top: 1rem;
            animation: fadeInUp 1s ease 0.5s both;
        }

        .result-countdown {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-top: 2rem;
            animation: fadeInUp 1s ease 0.8s both;
        }

        @keyframes resultReveal {
            0% {
                transform: scale(0.5) translateY(30px);
                opacity: 0;
            }

            60% {
                transform: scale(1.1) translateY(-5px);
            }

            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeInUp {
            0% {
                transform: translateY(20px);
                opacity: 0;
            }

            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* === CONFETTI === */
        .confetti-container {
            position: fixed;
            inset: 0;
            z-index: 50;
            pointer-events: none;
            overflow: hidden;
        }

        .confetti-piece {
            position: absolute;
            top: -20px;
            width: 10px;
            height: 10px;
            animation: confettiFall linear forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(110vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* === PROGRESS BAR === */
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--cyan), var(--purple));
            z-index: 200;
            transition: width 0.3s linear;
            box-shadow: 0 0 10px var(--cyan-glow);
        }

        /* === PHASE DOTS (bottom) === */
        .phase-dots {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 0.75rem;
        }

        .phase-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            transition: all 0.5s ease;
        }

        .phase-dot.active {
            background: var(--cyan);
            box-shadow: 0 0 12px var(--cyan-glow);
            transform: scale(1.3);
        }

        .phase-dot.done {
            background: var(--purple);
        }
    </style>
</head>

<body>

    <canvas id="waveCanvas"></canvas>
    <div class="progress-bar" id="progressBar" style="width: 0%"></div>

    <div class="status-bar">
        <div class="logo"><img src="/NS_isolated_white.png" class="logo-img logo-img-sm" alt="">NEUROSNATCH</div>
        <div class="right-controls">
            <div class="phase" id="phaseText">
                <span class="dot"></span>
                <span id="phaseLabel">READY</span>
            </div>
        </div>
    </div>

    <div class="container">

        <!-- IDLE -->
        <div class="screen active" id="screen-idle">
            <div class="title"><img src="/NS_isolated_white.png" class="logo-img logo-img-lg" alt="">NEUROSNATCH</div>
            <div class="subtitle">Your brain picks the ending</div>

            <div class="eeg-config">
                <div class="config-row">
                    <label for="bandSelect">Brainwave</label>
                    <select id="bandSelect">
                        <option value="0">Delta</option>
                        <option value="1">Theta</option>
                        <option value="2" selected>Alpha</option>
                        <option value="3">Beta Low</option>
                        <option value="4">Beta Mid</option>
                        <option value="5">Beta High</option>
                        <option value="6">Gamma</option>
                    </select>
                </div>
                <div class="config-row">
                    <label for="channelSelect">Channel</label>
                    <select id="channelSelect">
                        <option value="1">Channel 1</option>
                        <option value="2">Channel 2</option>
                        <option value="3">Channel 3</option>
                        <option value="4">Channel 4</option>
                        <option value="5" selected>Channel 5</option>
                        <option value="6">Channel 6</option>
                        <option value="7">Channel 7</option>
                        <option value="8">Channel 8</option>
                        <option value="avg">All Channels (avg)</option>
                    </select>
                </div>
            </div>

            <button class="start-btn" onclick="startSession()">Begin Session</button>
        </div>

        <!-- CLIP 1 (Calm) -->
        <div class="screen video-screen" id="screen-clip1">
            <div class="video-label calm">Clip 1</div>
            <video id="video-clip1" playsinline></video>
            <div class="video-timer" id="timer-clip1"></div>
            <div class="eeg-graph-wrap">
                <canvas class="eeg-graph" id="eegGraph1"></canvas>
                <div class="eeg-graph-label" id="eegGraphLabel1"></div>
            </div>
        </div>

        <!-- CLIP 2 (Excited) -->
        <div class="screen video-screen" id="screen-clip2">
            <div class="video-label excited">Clip 2</div>
            <video id="video-clip2" playsinline></video>
            <div class="video-timer" id="timer-clip2"></div>
            <div class="eeg-graph-wrap">
                <canvas class="eeg-graph" id="eegGraph2"></canvas>
                <div class="eeg-graph-label" id="eegGraphLabel2"></div>
            </div>
        </div>

        <!-- RESULT -->
        <div class="screen" id="screen-result">
            <div class="result-container">
                <div class="result-pre">Your brain resonated with</div>
                <div class="result-choice" id="resultChoice"></div>
                <div class="result-emoji" id="resultEmoji"></div>
                <div class="result-desc" id="resultDesc"></div>
                <div class="result-countdown" id="resultCountdown"></div>
            </div>
        </div>

        <!-- ENDING VIDEO -->
        <div class="screen video-screen" id="screen-ending">
            <div class="video-label" id="endingLabel">Your Ending</div>
            <video id="video-ending" playsinline></video>
        </div>

        <!-- DONE -->
        <div class="screen" id="screen-done">
            <div class="title" style="font-size: clamp(2rem, 5vw, 4rem);">Session Complete</div>
            <div class="subtitle" style="margin-top: 1rem;">Thank you for the experience</div>
            <button class="start-btn" style="margin-top: 2rem;" onclick="resetSession()">New Session</button>
        </div>

    </div>

    <!-- Phase dots -->
    <div class="phase-dots" id="phaseDots">
        <div class="phase-dot" data-phase="0"></div>
        <div class="phase-dot" data-phase="1"></div>
        <div class="phase-dot" data-phase="2"></div>
        <div class="phase-dot" data-phase="3"></div>
    </div>

    <!-- Confetti -->
    <div class="confetti-container" id="confettiContainer"></div>

    <script>
        // ============================================================
        //  CONFIG
        // ============================================================
        const PHASES = ['idle', 'clip1', 'clip2', 'result', 'ending', 'done'];
        let currentPhase = 'idle';
        let calibrated = false;

        const CONFIG = {
            resultRevealDuration: 5,
            calibrationDuration: 15,
            pollInterval: 300,
        };

        // ============================================================
        //  SCREEN TRANSITIONS
        // ============================================================
        function showScreen(name) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screen = document.getElementById(`screen-${name}`);
            if (screen) screen.classList.add('active');
            currentPhase = name;
            updatePhaseDots(name);
            updatePhaseLabel(name);
        }

        function updatePhaseDots(phase) {
            const idx = PHASES.indexOf(phase);
            document.querySelectorAll('.phase-dot').forEach((dot, i) => {
                dot.classList.remove('active', 'done');
                if (i === idx) dot.classList.add('active');
                else if (i < idx) dot.classList.add('done');
            });
        }

        function updatePhaseLabel(phase) {
            const labels = {
                idle: 'READY',
                clip1: 'CLIP 1',
                clip2: 'CLIP 2',
                result: 'RESULT',
                ending: 'YOUR ENDING',
                done: 'COMPLETE'
            };
            document.getElementById('phaseLabel').textContent = labels[phase] || phase.toUpperCase();
        }

        function setProgress(pct) {
            document.getElementById('progressBar').style.width = pct + '%';
        }

        // ============================================================
        //  MAIN SESSION FLOW (seamless — no analyzing screen)
        // ============================================================
        let pendingDecision = null;  // filled by background polling during clip 2

        async function startSession() {
            pendingDecision = null;
            console.log('[DEBUG] Session started');

            // Send EEG config (band + channel) to server
            const bandIdx = parseInt(document.getElementById('bandSelect').value);
            const channelVal = document.getElementById('channelSelect').value;
            try {
                await fetch('/api/eeg-config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ band: bandIdx, channel: channelVal })
                });
                console.log('[DEBUG] EEG config sent: band=' + bandIdx + ' channel=' + channelVal);
            } catch (e) { console.error('[DEBUG] Failed to send EEG config', e); }

            // Reset server state
            try { await fetch('/api/reset', { method: 'POST' }); } catch (e) { }

            // Clip 1 (calm) — report start to server
            showScreen('clip1');
            setProgress(5);
            startEegGraph();
            console.log('[DEBUG] Playing clip 1...');
            await playVideo('video-clip1', '/videos/calm_clip.mp4', 'timer-clip1', 0, 45, 1);
            console.log('[DEBUG] Clip 1 finished');

            // Clip 2 (excited) — immediately, no gap
            // Start polling for decision + preloading ending video IN PARALLEL
            showScreen('clip2');
            setProgress(50);
            startDecisionPolling();
            console.log('[DEBUG] Playing clip 2 + polling for decision...');
            await playVideo('video-clip2', '/videos/excited_clip.mp4', 'timer-clip2', 50, 90, 2);
            console.log('[DEBUG] Clip 2 finished, pendingDecision =', pendingDecision);

            stopEegGraph();

            // Clip 2 just ended — decision should already be here
            if (!pendingDecision) {
                console.log('[DEBUG] No decision yet, entering fallback wait...');
                pendingDecision = await waitForDecision();
            }

            // INSTANT switch to ending — no result reveal screen
            console.log('[DEBUG] Switching directly to ending:', pendingDecision);
            await playEnding(pendingDecision);
        }

        function startDecisionPolling() {
            const poll = setInterval(async () => {
                try {
                    const res = await fetch('/api/decision');
                    const data = await res.json();
                    if (data.decision) {
                        pendingDecision = data.decision;
                        clearInterval(poll);
                        console.log('[DEBUG] Decision received during clip 2:', data.decision);

                        // Preload ending video so it's ready the instant clip 2 ends
                        const endingVideo = document.getElementById('video-ending');
                        endingVideo.src = data.decision === 'calm'
                            ? '/videos/calm_ending.mp4'
                            : '/videos/excited_ending.mp4';
                        endingVideo.load();
                        console.log('[DEBUG] Preloading ending video...');
                    }
                } catch (e) { }
            }, CONFIG.pollInterval);
            window._decisionPoll = poll;
        }

        // ============================================================
        //  COUNTDOWN TIMER
        // ============================================================
        function countdown(elementId, seconds) {
            return new Promise(resolve => {
                const el = document.getElementById(elementId);
                let remaining = seconds;
                el.textContent = remaining;
                const interval = setInterval(() => {
                    remaining--;
                    el.textContent = remaining;
                    if (remaining <= 0) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 1000);
            });
        }

        // ============================================================
        //  VIDEO PLAYBACK
        // ============================================================
        function playVideo(videoId, src, timerId, progressStart, progressEnd, clipNumber) {
            return new Promise((resolve) => {
                const video = document.getElementById(videoId);
                const timer = document.getElementById(timerId);

                video.src = src;
                video.load();

                video.onloadedmetadata = () => {
                    console.log(`[DEBUG] Clip ${clipNumber} metadata loaded — duration: ${video.duration}s`);
                    // Report clip start + duration to server so eeg.py knows the length
                    fetch('/api/clip-started', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ clip: clipNumber, duration: video.duration })
                    }).then(r => r.json()).then(d => console.log(`[DEBUG] clip-started response:`, d))
                      .catch(e => console.error(`[DEBUG] clip-started error:`, e));
                };

                video.oncanplay = () => {
                    video.play().catch(() => { video.muted = true; video.play(); });
                };

                video.ontimeupdate = () => {
                    if (timer && video.duration) {
                        timer.textContent = `${Math.floor(video.currentTime)}s / ${Math.floor(video.duration)}s`;
                        const pct = progressStart + (video.currentTime / video.duration) * (progressEnd - progressStart);
                        setProgress(pct);
                    }
                };

                video.onended = () => resolve();
                video.onerror = () => {
                    if (timer) timer.textContent = 'Video not found — skipping...';
                    setTimeout(resolve, 3000);
                };
            });
        }

        // ============================================================
        //  DECISION POLLING (seamless — no "analyzing" UI)
        // ============================================================
        function waitForDecision() {
            console.log('[DEBUG] waitForDecision: starting fallback poll...');
            return new Promise(resolve => {
                const poll = setInterval(async () => {
                    try {
                        const res = await fetch('/api/decision');
                        const data = await res.json();
                        console.log('[DEBUG] waitForDecision poll:', data);
                        if (data.decision) {
                            clearInterval(poll);
                            console.log('[DEBUG] waitForDecision resolved:', data.decision);
                            resolve(data.decision);
                        }
                    } catch (e) { console.error('[DEBUG] waitForDecision error:', e); }
                }, CONFIG.pollInterval);
            });
        }

        // ============================================================
        //  PLAY ENDING (instant switch from clip 2, no reveal screen)
        // ============================================================
        async function playEnding(choice) {
            // Switch screen instantly
            showScreen('ending');
            setProgress(92);

            const endingLabel = document.getElementById('endingLabel');
            endingLabel.textContent = choice === 'calm' ? 'Your Calm Ending' : 'Your Exciting Ending';
            endingLabel.className = `video-label ${choice}`;

            const endingVideo = document.getElementById('video-ending');

            // If not preloaded yet (fallback), set source now
            if (!endingVideo.src || endingVideo.src === window.location.href) {
                endingVideo.src = choice === 'calm' ? '/videos/calm_ending.mp4' : '/videos/excited_ending.mp4';
                endingVideo.load();
            }

            await new Promise(resolve => {
                // If already buffered enough, play immediately
                if (endingVideo.readyState >= 3) {
                    endingVideo.play().catch(() => { endingVideo.muted = true; endingVideo.play(); });
                } else {
                    endingVideo.oncanplay = () => {
                        endingVideo.play().catch(() => { endingVideo.muted = true; endingVideo.play(); });
                    };
                }

                endingVideo.ontimeupdate = () => {
                    if (endingVideo.duration) {
                        const pct = 92 + (endingVideo.currentTime / endingVideo.duration) * 8;
                        setProgress(pct);
                    }
                };

                endingVideo.onended = resolve;
                endingVideo.onerror = () => setTimeout(resolve, 5000);
            });

            setProgress(100);
            showScreen('done');
        }

        // ============================================================
        //  RESULT REVEAL (kept for reference but no longer used in flow)
        // ============================================================
        async function showResult(choice) {
            showScreen('result');
            setProgress(90);

            const choiceEl = document.getElementById('resultChoice');
            const emojiEl = document.getElementById('resultEmoji');
            const descEl = document.getElementById('resultDesc');
            const countdownEl = document.getElementById('resultCountdown');

            if (choice === 'calm') {
                choiceEl.textContent = 'CALM';
                choiceEl.className = 'result-choice calm';
                emojiEl.textContent = '\u{1F9D8}';
                descEl.textContent = 'Your brain found deeper peace in the tranquil content';
                spawnConfetti(['#6ee7b7', '#3b82f6', '#a78bfa', '#22d3ee']);
            } else {
                choiceEl.textContent = 'EXCITED';
                choiceEl.className = 'result-choice excited';
                emojiEl.textContent = '\u26A1';
                descEl.textContent = 'Your brain lit up with the thrilling content';
                spawnConfetti(['#f472b6', '#f59e0b', '#ef4444', '#a855f7']);
            }

            // Show result briefly, then play ending
            for (let i = CONFIG.resultRevealDuration; i > 0; i--) {
                countdownEl.textContent = `Playing your ending in ${i}s...`;
                await sleep(1000);
            }

            // Play ending video
            showScreen('ending');
            setProgress(95);
            const endingLabel = document.getElementById('endingLabel');
            endingLabel.textContent = choice === 'calm' ? 'Your Calm Ending' : 'Your Exciting Ending';
            endingLabel.className = `video-label ${choice}`;

            const endingVideo = document.getElementById('video-ending');
            endingVideo.src = choice === 'calm' ? '/videos/calm_ending.mp4' : '/videos/excited_ending.mp4';
            endingVideo.load();

            await new Promise(resolve => {
                endingVideo.oncanplay = () => {
                    endingVideo.play().catch(() => { endingVideo.muted = true; endingVideo.play(); });
                };
                endingVideo.onended = resolve;
                endingVideo.onerror = () => setTimeout(resolve, 5000);
            });

            setProgress(100);
            showScreen('done');
        }

        // ============================================================
        //  CONFETTI
        // ============================================================
        function spawnConfetti(colors) {
            const container = document.getElementById('confettiContainer');
            container.innerHTML = '';
            for (let i = 0; i < 80; i++) {
                const piece = document.createElement('div');
                piece.classList.add('confetti-piece');
                piece.style.left = Math.random() * 100 + 'vw';
                piece.style.background = colors[Math.floor(Math.random() * colors.length)];
                piece.style.width = (Math.random() * 8 + 4) + 'px';
                piece.style.height = (Math.random() * 8 + 4) + 'px';
                piece.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
                piece.style.animationDuration = (Math.random() * 2 + 2) + 's';
                piece.style.animationDelay = Math.random() * 1 + 's';
                container.appendChild(piece);
            }
            setTimeout(() => container.innerHTML = '', 5000);
        }

        // ============================================================
        //  RESET
        // ============================================================
        async function resetSession() {
            await fetch('/api/reset', { method: 'POST' });
            setProgress(0);
            showScreen('idle');
        }

        // ============================================================
        //  BACKGROUND WAVE ANIMATION
        // ============================================================
        function initWaveCanvas() {
            const canvas = document.getElementById('waveCanvas');
            const ctx = canvas.getContext('2d');
            let w, h;

            function resize() { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; }
            resize();
            window.addEventListener('resize', resize);

            const waves = [
                { freq: 0.008, amp: 40, speed: 0.015, color: 'rgba(0, 240, 255, 0.15)', yOffset: 0.3 },
                { freq: 0.012, amp: 30, speed: 0.02, color: 'rgba(168, 85, 247, 0.12)', yOffset: 0.5 },
                { freq: 0.006, amp: 50, speed: 0.01, color: 'rgba(0, 240, 255, 0.08)', yOffset: 0.7 },
                { freq: 0.015, amp: 20, speed: 0.025, color: 'rgba(110, 231, 183, 0.1)', yOffset: 0.4 },
                { freq: 0.01, amp: 35, speed: 0.018, color: 'rgba(244, 114, 182, 0.08)', yOffset: 0.6 },
            ];

            let t = 0;
            function draw() {
                ctx.clearRect(0, 0, w, h);
                waves.forEach(wave => {
                    ctx.beginPath();
                    ctx.moveTo(0, h * wave.yOffset);
                    for (let x = 0; x <= w; x += 2) {
                        const y = h * wave.yOffset +
                            Math.sin(x * wave.freq + t * wave.speed) * wave.amp +
                            Math.sin(x * wave.freq * 2.5 + t * wave.speed * 1.5) * wave.amp * 0.3;
                        ctx.lineTo(x, y);
                    }
                    ctx.strokeStyle = wave.color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
                t++;
                requestAnimationFrame(draw);
            }
            draw();
        }

        // ==================== EEG LIVE GRAPH ====================
        let eegGraphActive = false;
        let eegGraphPollTimer = null;
        let eegGraphHistory = [];

        function startEegGraph() {
            if (eegGraphActive) return;
            eegGraphActive = true;
            eegGraphHistory = [];

            // Set label from dropdown selections
            const bandNames = ['Delta', 'Theta', 'Alpha', 'Beta Low', 'Beta Mid', 'Beta High', 'Gamma'];
            const bandSel = document.getElementById('bandSelect');
            const chSel = document.getElementById('channelSelect');
            const bandLabel = bandNames[parseInt(bandSel.value)] || 'Alpha';
            const chVal = chSel.value;
            const chLabel = chVal === 'avg' ? 'All Channels' : 'Channel ' + chVal;
            const caption = bandLabel + ' \u00B7 ' + chLabel;
            const lbl1 = document.getElementById('eegGraphLabel1');
            const lbl2 = document.getElementById('eegGraphLabel2');
            if (lbl1) lbl1.textContent = caption;
            if (lbl2) lbl2.textContent = caption;

            // Size canvases once
            const canvases = [
                document.getElementById('eegGraph1'),
                document.getElementById('eegGraph2')
            ];
            canvases.forEach(c => {
                if (!c) return;
                const rect = c.getBoundingClientRect();
                c.width = rect.width * devicePixelRatio;
                c.height = rect.height * devicePixelRatio;
            });

            // Poll + draw on each tick (250ms)
            eegGraphPollTimer = setInterval(async () => {
                try {
                    const res = await fetch('/api/eeg-live');
                    const data = await res.json();
                    if (data.history && data.history.length > 0) {
                        eegGraphHistory = data.history;
                    }
                } catch (e) { }
                drawEegGraph(canvases);
            }, 250);

            // Initial draw
            drawEegGraph(canvases);
        }

        function drawEegGraph(canvases) {
            canvases.forEach(canvas => {
                if (!canvas) return;
                const W = canvas.width / devicePixelRatio;
                const H = canvas.height / devicePixelRatio;
                const ctx = canvas.getContext('2d');
                ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
                ctx.clearRect(0, 0, W, H);

                const hist = eegGraphHistory;
                if (hist.length < 2) {
                    ctx.strokeStyle = 'rgba(0, 200, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(0, H / 2);
                    ctx.lineTo(W, H / 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = 'rgba(0, 200, 255, 0.4)';
                    ctx.font = '11px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Waiting for EEG data\u2026', W / 2, H / 2 - 8);
                    return;
                }

                // Auto-scale
                let mn = Infinity, mx = -Infinity;
                for (const v of hist) {
                    if (v < mn) mn = v;
                    if (v > mx) mx = v;
                }
                const range = mx - mn || 1;
                mn -= range * 0.1;
                mx += range * 0.1;

                const padTop = 6, padBot = 6;
                const graphH = H - padTop - padBot;

                // Gradient fill
                const grad = ctx.createLinearGradient(0, padTop, 0, H - padBot);
                grad.addColorStop(0, 'rgba(0, 180, 255, 0.25)');
                grad.addColorStop(1, 'rgba(0, 180, 255, 0.02)');

                ctx.beginPath();
                for (let i = 0; i < hist.length; i++) {
                    const x = (i / (hist.length - 1)) * W;
                    const y = padTop + graphH - ((hist[i] - mn) / (mx - mn)) * graphH;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.lineTo(W, H - padBot);
                ctx.lineTo(0, H - padBot);
                ctx.closePath();
                ctx.fillStyle = grad;
                ctx.fill();

                // Line
                ctx.beginPath();
                for (let i = 0; i < hist.length; i++) {
                    const x = (i / (hist.length - 1)) * W;
                    const y = padTop + graphH - ((hist[i] - mn) / (mx - mn)) * graphH;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.9)';
                ctx.lineWidth = 1.5;
                ctx.lineJoin = 'round';
                ctx.stroke();

                // Latest value dot
                const lastVal = hist[hist.length - 1];
                const lastY = padTop + graphH - ((lastVal - mn) / (mx - mn)) * graphH;
                ctx.beginPath();
                ctx.arc(W - 2, lastY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 240, 255, 1)';
                ctx.fill();

                // Value label
                ctx.fillStyle = 'rgba(0, 220, 255, 0.8)';
                ctx.font = '10px JetBrains Mono, monospace';
                ctx.textAlign = 'right';
                ctx.fillText(lastVal.toFixed(2), W - 6, 14);
            });
        }

        function stopEegGraph() {
            eegGraphActive = false;
            if (eegGraphPollTimer) { clearInterval(eegGraphPollTimer); eegGraphPollTimer = null; }
        }

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        window.addEventListener('DOMContentLoaded', () => { initWaveCanvas(); });
    </script>

</body>

</html>